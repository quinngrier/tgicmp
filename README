Comparing integers in C

One of the difficulties with C is its surprising behavior when comparing
integers with different types. For example, -1 < 0u is conceptually true
but actually false. This is because of the usual arithmetic conversions,
which are the rules for consolidating operands with different types. In
this example, the operands have types int and unsigned int, causing the
int to be converted to unsigned int. Because this conversion is modular,
the comparison becomes UINT_MAX < 0u, which is false. This leads to the
following definition.

Definition 1. An integer comparison is normal if its conceptual result
matches its actual result.

The normality of an integer comparison depends entirely on the effects
of the usual arithmetic conversions, which in turn depend entirely on
the types and values of the operands. In some cases, the value of one
operand cannot be preserved, and normality may be lost. A thorough
analysis leads to the following theorem.

Theorem 2. If both operands of an integer comparison have signed type or
neither has negative value, then the comparison is normal.

Proof. The idea of this proof applies to all versions of the C standard,
but C99 will be used as the point of reference.

The usual arithmetic conversions, which are given in C99 6.3.1.8p1, have
five cases for an integer comparison. Each case converts neither, one,
or both operands to another type. For the comparison to be normal, it
suffices to show that all conversions preserve value. The integer
promotions are irrelevant because they always preserve value.

In case 1, no conversions occur.

In case 2, C99 6.2.5p8 implies that the conversion preserves value.

In case 3, the assumption of the theorem implies that neither operand
has negative value. Let S be the signed type and U be the unsigned type.
If S corresponds to U as described by C99 6.2.5p6, then C99 6.2.5p9
implies that the conversion preserves value. Otherwise, C99 6.2.5p6
implies that there exists another signed type S' that corresponds to U,
C99 6.3.1.1p1 implies that S' and U have the same rank, the case itself
and C99 6.3.1.1p1 imply that this rank is larger than that of S, and C99
6.2.5p8 and C99 6.2.5p9 imply that the conversion preserves value.

In case 4, the case itself implies that the conversion preserves value.

In case 5, the assumption of the theorem implies that neither operand
has negative value. Let S be the signed type, U be the unsigned type,
and U' be the unsigned type corresponding to S. Because case 3 did not
apply, the rank of S is larger than that of U, C99 6.3.1.1p1 implies
that the S and U' have the same rank, and C99 6.2.5p8 and C99 6.2.5p9
imply that both conversions preserve value. QED

In practice it is best to avoid integer comparisons that are not normal.
The usual advice is to avoid comparisons where one operand has signed
type and the other has unsigned type. Indeed, most compilers can be
instructed to produce warnings if this advice is not followed. The
following corollary shows why this advice is true.

Corollary 3. If both operands of an integer comparison have signed type
or both have unsigned type, then the comparison is normal.

Proof. If both operands have signed type, then Theorem 2 implies that
the comparison is normal. If both have unsigned type, then neither has
negative value, and Theorem 2 implies that the comparison is normal. QED

Although Corollary 3 is usually easy to follow in practice, there are
situations where it can be difficult. Fortunately, there is a way to
compute the conceptual result of an integer comparison regardless of
normality.

Corollary 4. If one operand of an integer comparison has signed type but
not negative value, then the comparison is normal.

Proof. If the other operand has signed type, then both have signed type,
and Theorem 2 implies that the comparison is normal. If it has unsigned
type, then neither has negative value, and Theorem 2 implies that the
comparison is normal. QED

Corollary 5. If both operands of an integer comparison have negative
value or neither has negative value, then the comparison is normal.

Proof. If both operands have negative value, then both have signed type,
and Theorem 2 implies that the comparison is normal. If neither has
negative value, then Theorem 2 implies that the comparison is normal.
QED

Suppose that x and y are integers with any types and values. We would
like to compute the abstract x < y. It follows from the key observation
that x < 0 and y < 0 are abstract. This lets us test if x and y are both
negative or not negative: (x < 0) == (y < 0). In this case, it follows
from the key observation that x < y is abstract. Otherwise, if exactly
one of x and y is negative, x < 0 is also the abstract x < y. Putting it
together, (x < 0) == (y < 0) ? x < y : x < 0 is the abstract x < y. The
> operator can be computed similarly, and the <=, >=, ==, and !=
operators can be computed from the < and > operators.

For convenience, we provide the header file tgicmp.h, which defines six
macros that implement the six comparison operators <, >, <=, >=, ==, and
!= as described.

The six macros are TGILT, TGIGT, TGILE, TGIGE, TGIEQ, and TGINE, which
correspond to the six operators. Each macro takes two arguments x and y,
each of which must be an expression with integer type but may otherwise
have any type and value. The expansion is a parenthesized expression
with type int and value 1 if x op y is true in the abstract or 0 if not,
where op is the corresponding operator. If x and y are suitable for use
in #if preprocessing directives, so is the expansion. If x and y are
integer constant expressions, so is the expansion. The expansion may
evaluate each of x and y more than once.

The header file is safe to include more than once. The only reserved
identifiers are the six macro names.

The authors of this file have waived all copyright and
related or neighboring rights to the extent permitted by
law as described by the CC0 1.0 Universal Public Domain
Dedication. You should have received a copy of the full
dedication along with this file, typically as a file
named <CC0-1.0.txt>. If not, it may be available at
<https://creativecommons.org/publicdomain/zero/1.0/>.
