Type-generic integer comparisons in C

One of the difficulties with C is its surprising behavior when comparing
integers with different types. For example, -1 < 0u is conceptually true
but actually false. This is because of the usual arithmetic conversions,
which are the rules for consolidating operands with different types. In
this example, the left operand has type int and the right unsigned int,
causing the int to be converted to unsigned int. Because this conversion
is modular, the comparison becomes UINT_MAX < 0u, which is false.

Definition. A comparison is normal if its conceptual result matches its
actual result.

The complete definition of the usual arithmetic conversions is given by
the C standard. When comparing integers, the key observation is that the
result is always abstract except perhaps when one operand has negative
value and the other has unsigned type. In this case, the value may be
converted to an unsigned type, which may change the result.

This difficulty is usually avoided by simply not comparing signed and
unsigned integers. Following this advice is usually easy, but sometimes
it would be nice if there were a workaround. Fortunately, there is.

Suppose that x and y are integers with any types and values. We would
like to compute the abstract x < y. It follows from the key observation
that x < 0 and y < 0 are abstract. This lets us test if x and y are both
negative or not negative: (x < 0) == (y < 0). In this case, it follows
from the key observation that x < y is abstract. Otherwise, if exactly
one of x and y is negative, x < 0 is also the abstract x < y. Putting it
together, (x < 0) == (y < 0) ? x < y : x < 0 is the abstract x < y. The
> operator can be computed similarly, and the <=, >=, ==, and !=
operators can be computed from the < and > operators.

For convenience, we provide the header file tgicmp.h, which defines six
macros that implement the six comparison operators <, >, <=, >=, ==, and
!= as described.

The six macros are TGILT, TGIGT, TGILE, TGIGE, TGIEQ, and TGINE, which
correspond to the six operators. Each macro takes two arguments x and y,
each of which must be an expression with integer type but may otherwise
have any type and value. The expansion is a parenthesized expression
with type int and value 1 if x op y is true in the abstract or 0 if not,
where op is the corresponding operator. If x and y are suitable for use
in #if preprocessing directives, so is the expansion. If x and y are
integer constant expressions, so is the expansion. The expansion may
evaluate each of x and y more than once.

The header file is safe to include more than once. The only reserved
identifiers are the six macro names.

The authors of this file have waived all copyright and
related or neighboring rights to the extent permitted by
law as described by the CC0 1.0 Universal Public Domain
Dedication. You should have received a copy of the full
dedication along with this file, typically as a file
named <CC0-1.0.txt>. If not, it may be available at
<https://creativecommons.org/publicdomain/zero/1.0/>.
