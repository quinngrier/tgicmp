Comparing integers in C

One of the difficulties with C is its surprising behavior when comparing
integers with different types. For example, -1 < 0u is conceptually true
but actually false. This is because of the usual arithmetic conversions,
which are the rules for consolidating operands with different types. In
this example, the operands have types int and unsigned int, causing the
int to be converted to unsigned int. Because this conversion is modular,
the comparison becomes UINT_MAX < 0u, which is false. This leads to the
following definition.

Definition 1. An integer comparison is normal if its conceptual result
matches its actual result.

In general, the normality of an integer comparison depends on the effect
of the usual arithmetic conversions, which in turn depends on the types
and values of the operands. In some cases, the value of one operand is
changed by the conversions, which may cause normality to be lost.

A thorough analysis of how this occurs leads to the following lemmas and
theorem. The ideas apply to all versions of C, but the C99 standard will
be used as the point of reference. The official copy of this standard
must be purchased, but several drafts with only minor differences are
freely available and should be easy to find. A draft is not included
along with this file because the copyright information is unclear.

Lemma Z. If T and U are different unsigned integer types and neither T
nor U is _Bool, then T and U have different ranks.

Proof. Since T is not _Bool, there exists a signed integer type T' that
corresponds to T by C99 6.2.5p6, and T and T' have the same rank by C99
6.3.1.1p1 item 4. Similarly, there exists a signed integer type U' that
corresponds to U, and U and U' have the same rank. T' and U' must also
be different types, for if they were the same type, then T and U would
be the same type by C99 6.2.5p6, which would contradict the assumption
that T and U are different types. Now, if T and U had the same rank,
then all four types would have the same rank. In particular, T' and U'
would have the same rank, which would contradict C99 6.3.1.1p1 item 1.
So T and U must have different ranks. QED

Lemma Y. If T is a signed integer type, U is an unsigned integer type, U
is not _Bool, and the rank of T is at most the rank of U, then the
nonnegative range of T is at most the range of U.

Proof. Since U is not _Bool, there exists a signed integer type U' that
corresponds to U by C99 6.2.5p6. The nonnegative range of U' is at most
the range of U by C99 6.2.5p9, so it suffices to show that the range of
T is at most the range of U'. Since the rank of T is at most the rank of
U by assumption and U and U' have the same rank by C99 6.3.1.1p1 item 4,
the rank of T is at most the rank of U'. If T and U' have the same rank,
then T and U' are the same type by C99 6.3.1.1p1 item 1, and the result
follows trivially. Otherwise, the rank of T is less than the rank of U',
and the result follows from C99 6.2.5p8. QED

Lemma X. If T is an integer type, U is an unsigned integer type, neither
T nor U is _Bool, and the rank of T is at most the rank of U, then the
nonnegative range of T is at most the range of U.

Proof. If T and U are the same type, then the result follows trivially.
Otherwise, if T is unsigned, then T and U have different ranks by Lemma
Z, so the rank of T is less than the rank of U, and the result follows
from C99 6.2.5p8. Otherwise, T is signed, and the result follows from
Lemma Y. QED

Theorem 2. If both operands of an integer comparison have signed type or
both have nonnegative value, then the comparison is normal.

Proof. It follows from C99 6.5.8p3 and C99 6.5.9p4 that the usual
arithmetic conversions are performed on the operands before their values
are compared. To show that the comparison is normal, it suffices to show
that the conversions preserve the values of the operands.

The usual arithmetic conversions are defined by C99 6.3.1.8p1. There are
two steps for integer operands: the integer promotions are performed on
the operands, and one of five cases is performed based on the types of
the promoted operands.

The integer promotions are defined by C99 6.3.1.1p2. These preserve the
values of the operands as clearly stated by C99 6.3.1.1p3. The types of
the operands may change, but this is inconsequential except that if an
operand has type _Bool, then it is converted to int, guaranteeing that
neither operand has type _Bool after promotion.

Each of the five cases converts neither, one, or both operands to a new
type. In case 1, neither operand is converted. In case 2, one operand is
converted, and its value is preserved by C99 6.2.5p8. In case 3, one
operand is converted, but it has nonnegative value by assumption, and
its value is preserved by Lemma X. In case 4, one operand is converted,
and its value is preserved by the case itself. In case 5, both operands
are converted, but both have nonnegative value by assumption, and their
values are preserved by Lemma X. QED

Note that the converse of Theorem 2 is not true: -2 < UINT_MAX is normal
but does not satisfy the assumption of the theorem. The normality here
is surprising because -2 is converted to unsigned int and its value is
lost, which suggests that normality should also be lost. However, the
comparison becomes UINT_MAX - 1 < UINT_MAX, which happens to preserve
the original conceptual result. In general, the value of one operand
being lost is not enough to cause normality to be lost.

In practice it is best to avoid integer comparisons that are not normal.
The usual advice is to avoid comparisons where one operand has signed
type and the other has unsigned type. Indeed, most compilers can be
instructed to produce warnings if this advice is not followed. The
following corollary shows why this advice is true.

Corollary 3. If both operands of an integer comparison have signed type
or both have unsigned type, then the comparison is normal.

Proof. If both operands have signed type, then Theorem 2 implies that
the comparison is normal. If both have unsigned type, then neither has
negative value, and Theorem 2 implies that the comparison is normal. QED

Although Corollary 3 is usually easy to follow in practice, there are
situations where it can be difficult. Fortunately, there is a way to
compute the conceptual result of an integer comparison regardless of
normality.

Corollary 4. If one operand of an integer comparison has signed type but
not negative value, then the comparison is normal.

Proof. If the other operand has signed type, then both have signed type,
and Theorem 2 implies that the comparison is normal. If it has unsigned
type, then neither has negative value, and Theorem 2 implies that the
comparison is normal. QED

Corollary 5. If both operands of an integer comparison have negative
value or neither has negative value, then the comparison is normal.

Proof. If both operands have negative value, then both have signed type,
and Theorem 2 implies that the comparison is normal. If neither has
negative value, then Theorem 2 implies that the comparison is normal.
QED

Suppose that x and y are integers with any types and values. We would
like to compute the abstract x < y. It follows from the key observation
that x < 0 and y < 0 are abstract. This lets us test if x and y are both
negative or not negative: (x < 0) == (y < 0). In this case, it follows
from the key observation that x < y is abstract. Otherwise, if exactly
one of x and y is negative, x < 0 is also the abstract x < y. Putting it
together, (x < 0) == (y < 0) ? x < y : x < 0 is the abstract x < y. The
> operator can be computed similarly, and the <=, >=, ==, and !=
operators can be computed from the < and > operators.

For convenience, we provide the header file tgicmp.h, which defines six
macros that implement the six comparison operators <, >, <=, >=, ==, and
!= as described.

The six macros are TGILT, TGIGT, TGILE, TGIGE, TGIEQ, and TGINE, which
correspond to the six operators. Each macro takes two arguments x and y,
each of which must be an expression with integer type but may otherwise
have any type and value. The expansion is a parenthesized expression
with type int and value 1 if x op y is true in the abstract or 0 if not,
where op is the corresponding operator. If x and y are suitable for use
in #if preprocessing directives, so is the expansion. If x and y are
integer constant expressions, so is the expansion. The expansion may
evaluate each of x and y more than once.

The header file is safe to include more than once. The only reserved
identifiers are the six macro names.

The authors of this file have waived all copyright and
related or neighboring rights to the extent permitted by
law as described by the CC0 1.0 Universal Public Domain
Dedication. You should have received a copy of the full
dedication along with this file, typically as a file
named <CC0-1.0.txt>. If not, it may be available at
<https://creativecommons.org/publicdomain/zero/1.0/>.
