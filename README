Type-generic integer comparisons in C

1. Overview

One of the difficulties with C is its surprising behavior when comparing
integers with different types. For example, -1 < 0u is conceptually true
but actually false. This is because of the usual arithmetic conversions,
which are the rules for consolidating operands with different types. In
this example, the operands have types int and unsigned int, causing the
int to be converted to unsigned int. Because this conversion is modular,
the comparison becomes UINT_MAX < 0u, which is false.

This difficulty can only arise when one operand has unsigned type and
the other has signed type and negative value. Depending on the types,
the usual arithmetic conversions can convert the negative value to an
unsigned type. Such a conversion is always modular, and the negative
value becomes its least residue. Depending on the values, the actual
result of the comparison can differ from the conceptual result.

The usual advice is to avoid comparisons where one operand has signed
type and the other has unsigned type. Compilers can usually be set to
emit warnings if this is not followed. This is usually easy to follow,
but there can be difficult situations. Fortunately, there is a way to
compute the conceptual result of an integer comparison no matter what
types and values are involved.

Let x and y be integers with any types and values, with the goal being
to compute the conceptual result of x < y. Notice that x < 0 and y < 0
are always conceptual, so (x < 0) == (y < 0) tests if both x and y are
negative or both are nonnegative. In this case, x < y itself is always
conceptual. Otherwise, exactly one of x and y is negative, so x < 0 is
the conceptual result of x < y. Combining these two possibilities into
one computation produces (x < 0) == (y < 0) ? x < y : x < 0, which is
always the conceptual result of x < y. The other comparison operators
can be computed from this one. For the complete formal development of
this idea, see Section 3.

Included along with this file is a header named tgicmp.h that defines
six macros for performing these type-generic integer comparisons. The
macros are named TGI{LT,GT,LE,GE,EQ,NE} and correspond in the obvious
way to the comparison operators. Each takes two arguments and returns
the appropriate result. For the complete specification of the header,
see Section 2.

2. Header specification

The tgicmp.h header defines six macros for performing type-generic
integer comparisons. If the header is included, it reserves the macro
names for use as specified. The header can be included multiple times
without any problems.

The six macros are TGILT, TGIGT, TGILE, TGIGE, TGIEQ, and TGINE, which
correspond to the usual comparison operators <, >, <=, >=, ==, and !=,
respectively. Each macro takes two arguments, each of which must be an
expression with integer type but may otherwise have any type and value.
Invalid arguments, in particular those with floating type, always cause
syntax errors. The macro expansion is a parenthesized expression with
type int and value 1 if the corresponding comparison of the first and
second arguments is conceptually true, or 0 if not. The arguments are
always evaluated more than once. If the arguments are suitable for use
in preprocessing directives, so is the expansion. If the arguments are
integer constant expressions, so is the expansion.

3. Formal development

This section rigorously develops the ideas behind type-generic integer
comparisons. The 2011 revision of the C standard (C11) will be assumed.
The key ideas also apply to the 1990 and 1999 revisions of the standard,
but some changes may be necessary. The official version of C11 can only
be purchased, but several drafts with only minor differences are freely
available and should be easy to find. A draft would be included along
with this file, but the copyright information is unclear.

A relational or equality expression whose operands have integer type is
called an integer comparison. The result of an integer comparison as if
the usual arithmetic conversions were not performed on its operands is
called the conceptual result of the comparison. An expression is said to
conceptualize an integer comparison if the result of the expression is
the conceptual result of the comparison. An integer comparison is said
to be conceptual if it conceptualizes itself. If an integer comparison
is conceptual, it is said to be strongly conceptual if neither operand
has its value changed by the usual arithmetic conversions, and weakly
conceptual if not.

Here are some examples of integer comparisons with various properties:

    Integer comparison | Result | Conceptual result | Conceptuality
   --------------------+--------+-------------------+---------------
      -2 < 0           |   1    |         1         |    Strong
      -2 < 0u          |   0    |         1         |     None
      -2 < UINT_MAX    |   1    |         1         |     Weak
       2 < UINT_MAX    |   1    |         1         |    Strong

Lemma Z. If T and U are different unsigned integer types and neither is
_Bool, then T and U have different ranks.

Proof. By C99 6.2.5p6, there exists signed integer types T' and U' that
correspond to T and U, respectively. T' and U' must be different types,
for if they were the same type, then T and U would be the same type by
C99 6.2.5p6. By C99 6.3.1.1p1 item 4, T and T' have the same rank, and
so do U and U'. Now, if T and U had the same rank, then all four types
would have the same rank. In particular, T' and U' would have the same
rank, which would contradict C99 6.3.1.1p1 item 1. QED

Lemma Y. If T is a signed integer type, U is an unsigned integer type, U
is not _Bool, and the rank of T is at most the rank of U, then the
nonnegative range of T is at most the range of U.

Proof. Since U is not _Bool, there exists a signed integer type U' that
corresponds to U by C99 6.2.5p6. The nonnegative range of U' is at most
the range of U by C99 6.2.5p9, so it suffices to show that the range of
T is at most the range of U'. Since the rank of T is at most the rank of
U by assumption and U and U' have the same rank by C99 6.3.1.1p1 item 4,
the rank of T is at most the rank of U'. If T and U' have the same rank,
then T and U' are the same type by C99 6.3.1.1p1 item 1, and the result
follows trivially. Otherwise, the rank of T is less than the rank of U',
and the result follows from C99 6.2.5p8. QED

Lemma X. If T is an integer type, U is an unsigned integer type, neither
T nor U is _Bool, and the rank of T is at most the rank of U, then the
nonnegative range of T is at most the range of U.

Proof. If T and U are the same type, then the result follows trivially.
Otherwise, if T is unsigned, then T and U have different ranks by Lemma
Z, so the rank of T is less than the rank of U, and the result follows
from C99 6.2.5p8. Otherwise, T is signed, and the result follows from
Lemma Y. QED

Theorem 2. If both operands of an integer comparison have signed type or
both have nonnegative value, then the comparison is normal.

Proof. By C99 6.5.8p3 and C99 6.5.9p4, the usual arithmetic conversions
are performed on the operands before their values are compared. To show
that the comparison is normal, it suffices to show that the conversions
preserve the values of the operands.

The usual arithmetic conversions are defined by C99 6.3.1.8p1. There are
two steps for integer operands: the integer promotions are performed on
the operands, and one of five cases is performed based on the types of
the promoted operands.

The integer promotions are defined by C99 6.3.1.1p2. These preserve the
values of the operands as clearly stated by C99 6.3.1.1p3. The types of
the operands may change, but this is inconsequential except that if an
operand has type _Bool, then it is converted to int, guaranteeing that
neither operand has type _Bool after promotion.

The aforementioned five cases are defined within the usual arithmetic
conversions themselves. Let T and U be the types of the operands.

In case 1, T and U are the same type and no action is taken.

In case 2, T and U are different types, both T and U are signed or both
are unsigned, the rank of T is less than the rank of U, and the operand
with type T is converted to U. The value is preserved by C99 6.2.5p8.

In case 3, T and U are different types, T is signed, U is unsigned, the
rank of T is at most the rank of U, and the operand with type T is
converted to U. The value is nonnegative by the assumption of the
theorem and is preserved by Lemma X.

In case 4, a conversion occurs and the value is preserved by the wording
of the case itself.

In case 5, T and U are different types, T is signed, U is unsigned, the
rank of T is larger than the rank of U, and both operands are converted
to the unsigned type T' that corresponds to T. Both values are
nonnegative by the assumption of the theorem and are preserved by Lemma
X. QED

Note that the converse of Theorem 2 is not true: -2 < UINT_MAX is normal
but does not satisfy the assumption of the theorem. The normality here
is surprising because -2 is converted to unsigned int and its value is
lost, which suggests that normality should also be lost. However, the
comparison becomes UINT_MAX - 1 < UINT_MAX, which happens to preserve
the original conceptual result. In general, the value of one operand
being lost is not enough to cause normality to be lost.

Corollary 3. If both operands of an integer comparison have signed type
or both have unsigned type, then the comparison is normal.

Proof. If both operands have signed type, then Theorem 2 implies that
the comparison is normal. If both have unsigned type, then neither has
negative value, and Theorem 2 implies that the comparison is normal. QED

Corollary 4. If one operand of an integer comparison has signed type but
not negative value, then the comparison is normal.

Proof. If the other operand has signed type, then both have signed type,
and Theorem 2 implies that the comparison is normal. If it has unsigned
type, then neither has negative value, and Theorem 2 implies that the
comparison is normal. QED

Corollary 5. If both operands of an integer comparison have negative
value or neither has negative value, then the comparison is normal.

Proof. If both operands have negative value, then both have signed type,
and Theorem 2 implies that the comparison is normal. If neither has
negative value, then Theorem 2 implies that the comparison is normal.
QED

Theorem K. If x and y are integers with any types and values, then the
actual result of (x < 0) == (y < 0) ? x < y : x < 0 matches the
conceptual result of x < y.

The six macros are TGILT, TGIGT, TGILE, TGIGE, TGIEQ, and TGINE, which
correspond to the six operators. Each macro takes two arguments x and y,
each of which must be an expression with integer type but may otherwise
have any type and value. The expansion is a parenthesized expression
with type int and value 1 if x op y is true in the abstract or 0 if not,
where op is the corresponding operator. If x and y are suitable for use
in #if preprocessing directives, so is the expansion. If x and y are
integer constant expressions, so is the expansion. The expansion may
evaluate each of x and y more than once.

The header file is safe to include more than once. The only reserved
identifiers are the six macro names.

The authors of this file have waived all copyright and
related or neighboring rights to the extent permitted by
law as described by the CC0 1.0 Universal Public Domain
Dedication. You should have received a copy of the full
dedication along with this file, typically as a file
named <CC0-1.0.txt>. If not, it may be available at
<https://creativecommons.org/publicdomain/zero/1.0/>.
